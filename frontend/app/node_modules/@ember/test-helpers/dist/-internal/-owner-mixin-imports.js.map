{"version":3,"file":"-owner-mixin-imports.js","sources":["../../src/-internal/-owner-mixin-imports.ts"],"sourcesContent":["// These utter shenanigans allow this to work regardless of what types you are\n// importing from. The idea is: you supply multiple imports, each of which is\n// mutually exclusive with the others in terms of valid imports, then ignore the\n// imports so they type check, then \"resolve\" between them based on which one is\n// actually defined. ðŸ˜­\n//\n// TODO: at the next major version (4.0), when we drop support for Ember < 5.1\n// or some later version and can therefore either depend *somewhat* more on\n// these import locations *or* can drop them entirely (depending on the path\n// taken in terms of the `Owner` stack), switch to the normal imports:\n// ```\n// import {\n//   ContainerProxyMixin,\n//   RegistryProxyMixin,\n// } from '@ember/-internals/runtime';\n// ```\n//\n// For now, we are stuck with this utterly horrifying hack to get the types for\n// these reliably.\n\n// This pair of types lets us check whether the imported type is set. We can\n// then use that to pick between the imported types. The first type produces\n// `any` when the type is otherwise not defined at all, which means we cannot\n// use it directly because `any` will fall through, well, basically *any* check\n// we might come up with... other than checking whether `any extends` it. The\n// second uses that to get back a `never` so we can then \"pick\" between the\n// imported types.\ntype AnyIfNeverElseT<T> = T extends never ? never : T;\ntype IsNever<T> = any extends AnyIfNeverElseT<T> ? never : T;\n\n// This mapped type does the \"picking\". You can pass it any number of types,\n// where only one should be available, and it will \"resolve\" that type.\n// Constraint: the `Array` type must include mutually exclusive types, such that\n// it should be impossible to ever get back more than one; otherwise, you will\n// end up with a union type of the two. That is very unlikely to be what you\n// want!\ntype NonNever<Types extends Array<unknown>> = {\n  [Index in keyof Types]: IsNever<Types[Index]>;\n}[number];\n\n// Imports from `@types`\n// @ts-ignore\nimport type CPM_DTS from '@ember/engine/-private/container-proxy-mixin.d.ts';\n// @ts-ignore\nimport type RPM_DTS from '@ember/engine/-private/registry-proxy-mixin.d.ts';\n\n// Imports from the preview types on 4.8\n// @ts-ignore\nimport type CPM_4_8 from '@ember/engine/-private/container-proxy-mixin';\n// @ts-ignore\nimport type RPM_4_8 from '@ember/engine/-private/registry-proxy-mixin';\n\n// Imports from the preview types on 4.12\n// @ts-ignore\nimport type CPM_4_12 from '@ember/-internals/runtime/lib/mixins/container_proxy';\n// @ts-ignore\nimport type RPM_4_12 from '@ember/-internals/runtime/lib/mixins/registry_proxy';\n\n// Imports available in the stable types\n// @ts-ignore\nimport type { ContainerProxyMixin as CPM_stable } from '@ember/-internals/runtime';\n// @ts-ignore\nimport type { RegistryProxyMixin as RPM_stable } from '@ember/-internals/runtime';\n\n// We also resolve the *values* from a \"stable\" location. However, the *types*\n// for the Ember namespace do not consistently include this definition (they do\n// on the stable types, but not in the preview or DT types), so cast as `any` so\n// that it resolves regardless.\nimport Ember from 'ember';\nexport const ContainerProxyMixin = (Ember as any)._ContainerProxyMixin;\nexport type ContainerProxyMixin = NonNever<\n  [CPM_DTS, CPM_4_8, CPM_4_12, CPM_stable]\n>;\n\nexport const RegistryProxyMixin = (Ember as any)._RegistryProxyMixin;\nexport type RegistryProxyMixin = NonNever<\n  [RPM_DTS, RPM_4_8, RPM_4_12, RPM_stable]\n>;\n"],"names":["ContainerProxyMixin","Ember","_ContainerProxyMixin","RegistryProxyMixin","_RegistryProxyMixin"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAmDaA,MAAAA,mBAAmB,GAAIC,KAAK,CAASC,qBAAoB;AAKzDC,MAAAA,kBAAkB,GAAIF,KAAK,CAASG;;;;"}